\section{Design and implementation of NEAT}

\subsection{Overview}
I implemented NEAT in Python based on the original C++ version, with some slight modifications.
Fitness sharing was used according to the following formula
\begin{equation*} \label{eq:1}
    Offspring = \frac{Average\:species\:fitness}{Total\:average\:species\:fitness} \cdot Population\:size
\end{equation*}
The compatibility threshold was adjusted during run-time as to maintain a set target number of species.
Population level stagnation detection, which replaces the entire population with offspring from the two best species
if no improvement is made over some threshold number of generations, was not implemented.

\subsection{Verification of functionality}
XOR is not linearly separable, which imposes some requirements on the ANN structures that can solve it (see Figure \ref{xor}).
This makes XOR a suitable problem for verifying that the implementation is somewhat correct and can evolve
the required structure - a sanity check. Another advantage is that it provides a direct way to compare my
implementation of NEAT with the original one, since the XOR results for it were published \cite{neat_main}.


\begin{figure}[h!]
    \begin{mdframed}
    \begin{subfigure}[t]{0.3\textwidth}
        \input{resources/tex/xor/truth_table.tex}
        \caption{}
    \end{subfigure}
    \begin{subfigure}[t]{0.3\textwidth}
        \input{resources/tex/xor/separable.tex}
        \caption{}
    \end{subfigure}
    \begin{subfigure}[t]{0.4\textwidth}
        \includegraphics[scale=0.3]{resources/tex/xor/xor_weights.png}
        \caption{}
    \end{subfigure}
    \end{mdframed}
    \caption{(a) Truth table for XOR. (b) XOR is not linearly separable.
    (c) Example of a minimal network structure capable of solving XOR. The inputs must be combined at a hidden node
    and the output node, the network calculates OR-AND.}
    \label{xor}
\end{figure}


Each network was evaluated with the four XOR input examples and assigned a fitness score according to the following expression
\begin{equation*} \label{eq:2}
    (4 - \sum_{i=1}^{4} expected_{i} - actual_{i})^2
\end{equation*}
where $expected_{i}$ is the correct answer for example $i$ and $actual_{i}$ is the actual output of the network for example $i$.

Data was collected from 100 runs (see Table \ref{xor_verification}). Each run was terminated once a network was found that solved
XOR or the number of network evaluations exceeded 20 000. The parameters used can be found in appendix \ref{parameter_values}.

\begin{table}[H]
    \centering
    \sisetup{table-format = 3.2}
    \begin{tabular}{lSS}
    \toprule
    Statistic & \multicolumn{1}{l}{Implementation} & \multicolumn{1}{l}{Original \cite{neat_main}} \\
    \midrule
    \rowcolor[gray]{.9} Mean evaluations & 4046 & 4755\\
    Standard deviation & 2316 & 2553\\
    \rowcolor[gray]{.9} Mean hidden nodes & 3.03 & 2.35\\
    Standard deviation & 1.49 & 1.11\\
    \rowcolor[gray]{.9} Mean links & 12.73 & 7.48\\
    Standard deviation & 3.78 & NaN\\
    Failures & 0 & 0\\
    Worst performance (evaluations) & 14355 & 13459 \\
    Minimal structures found & 14 & 22\\
    \bottomrule
    \end{tabular}
    \smallskip
    \caption{Comparison of performance on XOR with the original NEAT. A population size of 150 networks was used.}
    \label{xor_verification}
\end{table}
\vspace{-1.5em}
The results are overall similar. While my implementation finds solutions in fewer
evaluations more consistently (see Figure \ref{evals}), the networks are on average larger
and fewer minimal structures are found. Besides the link and node mutation rates, the
parameters used were identical.

\begin{figure}[H]
    \centering
    \input{resources/results/xor_evals.pgf}
    \caption{Histogram of the number of evaluated networks before XOR was solved over 100 runs. The width of each bin is 1000.}
    \label{evals}
\end{figure}